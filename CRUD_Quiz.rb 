Q1. Where are we instantiating instances of the Property class?

console.rb

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

properties.rb

Q3. In console.rb, which lines modify the database?

property1.save() etc

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

#if(statement) the option has an id store it, the ruby stuff doesnt but the database does. so the database returns it when it is needed.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?

in the RETURNING id" section where the database assigns the id and we take it out?
@id = db.exec_prepared("save", values)[0]["id"]

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?

it's the only unique identifier we have between the rows and stops nil being returned?

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

for encapsulation

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?

is it the hash in an array?
@id = db.exec_prepared("save", values)[0]["id"]
accessing the zero index and the hash "id"

Q9. Why do we use prepared statements when performing database operations?

to stop the code being altered by mistake or on purpose

Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?

the id and the address as these are the id's theyre being searched for?


Q11. What are their return values?

id takes an integer
address takes a string

instance of a property is returned
